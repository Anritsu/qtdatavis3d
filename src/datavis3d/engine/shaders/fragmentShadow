varying highp vec4 shadowCoord;
varying highp vec2 UV;
varying highp vec3 position_wrld;
varying highp vec3 normal_cmr;
varying highp vec3 eyeDirection_cmr;
varying highp vec3 lightDirection_cmr;

uniform highp float lightStrength;
uniform highp float ambientStrength;
uniform sampler2D textureSampler;
//uniform sampler2DShadow shadowMap; // use with version 2
uniform sampler2D shadowMap; // use with version 1

// Version 1: Use this to see the shadow map

void main() {
    float shadowFactor = 1.0; // default to '1' meaning "no shadow"
    float epsilon = 0.1; // increase value to remove little artifacts
    vec4 shadCoordsPD = shadowCoord / shadowCoord.w;
    if (shadowCoord.w <= 0.0) { // ignore negative projection
        shadowFactor = 1.0;
    } else if (shadCoordsPD.x < 0.0 || shadCoordsPD.y < 0.0) { // outside light frustum, ignore
        shadowFactor = 1.0;
    } else if (shadCoordsPD.x >= 1.0 || shadCoordsPD.y >= 1.0) { // outside light frustum, ignore
        shadowFactor = 1.0;
    } else {
        float shadow = texture2D(shadowMap, shadCoordsPD.xy).x;
        if (shadow + epsilon < shadCoordsPD.z) {
            shadowFactor = 0.0;
        }
    }
    // shadow is dark gray, other parts bright yellow
    gl_FragColor = vec4(0.8, 0.8, 0.0, 1.0) * shadowFactor + vec4(0.2, 0.2, 0.2, 1.0);
}

// Version 2: Use this normally
/*
void main() {
    highp vec3 materialDiffuseColor = vec3(0.8, 0.8, 0.0);//texture2D(textureSampler, UV).rgb;
    highp vec3 materialAmbientColor = vec3(ambientStrength, ambientStrength, ambientStrength) * materialDiffuseColor;
    highp vec3 materialSpecularColor = vec3(1.0, 1.0, 1.0);

    highp vec3 n = normalize(normal_cmr);
    highp vec3 l = normalize(lightDirection_cmr);
    highp float cosTheta = dot(n, l);
    if (cosTheta < 0.0) { cosTheta = 0.0; }
    if (cosTheta > 1.0) { cosTheta = 1.0; }

    highp vec3 E = normalize(eyeDirection_cmr);
    highp vec3 R = reflect(-l, n);
    highp float cosAlpha = dot(E, R);
    if (cosAlpha < 0.0) { cosAlpha = 0.0; }
    if (cosAlpha > 1.0) { cosAlpha = 1.0; }

    highp float visibility = 1.0;
    highp float bias = 0.005;

    //highp float bias = 0.005 * tan(acos(cosTheta));
    //if (bias < 0.0) { bias = 0.0; }
    //if (bias > 0.01) { bias = 0.01; }

    visibility -= 0.8 * (1.0 - shadow2D(shadowMap, vec3(shadowCoord.xy, (shadowCoord.z - bias) / shadowCoord.w)).r);

    gl_FragColor.rgb =
        materialAmbientColor +
        visibility * materialDiffuseColor * lightStrength * cosTheta +
        visibility * materialSpecularColor * lightStrength * (cosAlpha * cosAlpha * cosAlpha * cosAlpha * cosAlpha);
    gl_FragColor.a = 1.0;
}
*/
